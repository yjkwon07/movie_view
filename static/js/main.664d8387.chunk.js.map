{"version":3,"sources":["Movie.js","App.js","serviceWorker.js","index.js"],"names":["MoviePoster","_ref2","poster","alt","react_default","a","createElement","src","title","className","MovieGeners","_ref3","genre","Movie","_ref","genres","synopsis","map","index","key","lib_default","text","maxLine","ellipsis","trimRight","basedOn","App","state","greeting","_getMovies","_callee","movies","regenerator_default","wrap","_context","prev","next","_this","_callApi","sent","setState","stop","fetch","then","response","json","data","catch","err","console","log","_rederMovies","movie","src_Movie","title_english","medium_cover_image","id","this","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"wUAwDA,SAASA,EAATC,GAAoC,IAAdC,EAAcD,EAAdC,OAAQC,EAAMF,EAANE,IAC1B,OACIC,EAAAC,EAAAC,cAAA,OAAKC,IAAKL,EAAQC,IAAKA,EAAKK,MAAOL,EAAKM,UAAU,iBAK1D,SAASC,EAATC,GAA8B,IAARC,EAAQD,EAARC,MAClB,OACIR,EAAAC,EAAAC,cAAA,QAAMG,UAAY,eAAeG,GAoB1BC,MAtDf,SAAAC,GAAmD,IAAnCN,EAAmCM,EAAnCN,MAAQN,EAA2BY,EAA3BZ,OAAQa,EAAmBD,EAAnBC,OAAQC,EAAWF,EAAXE,SACpC,OACIZ,EAAAC,EAAAC,cAAA,OAAKG,UAAY,SACbL,EAAAC,EAAAC,cAAA,OAAKG,UAAW,gBACZL,EAAAC,EAAAC,cAACN,EAAD,CAAaE,OAAQA,EAAQC,IAAKK,KAEtCJ,EAAAC,EAAAC,cAAA,OAAKG,UAAU,eACXL,EAAAC,EAAAC,cAAA,UAAKE,GACLJ,EAAAC,EAAAC,cAAA,OAAKG,UAAU,gBACVM,EAAOE,IAAK,SAACL,EAAOM,GAAR,OAAkBd,EAAAC,EAAAC,cAACI,EAAD,CAAaE,MAAOA,EAAOO,IAAKD,MAC/Dd,EAAAC,EAAAC,cAAA,KAAGG,UAAU,kBACTL,EAAAC,EAAAC,cAACc,EAAAf,EAAD,CACIgB,KAAML,EACNM,QAAQ,IACRC,SAAS,MACTC,WAAS,EACTC,QAAQ,iBCgDnBC,6MA7EbC,MAAQ,CACNC,SAAW,WAyBbC,gCAAa,SAAAC,IAAA,IAAAC,EAAA,OAAAC,EAAA3B,EAAA4B,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cAAAF,EAAAE,KAAA,EAGUC,EAAKC,WAHf,OAGLP,EAHKG,EAAAK,KASXF,EAAKG,SAAS,CACXT,WAVQ,wBAAAG,EAAAO,SAAAX,QAcbQ,SAAY,WACV,OAAOI,MAAM,iEACZC,KAAK,SAAAC,GAAQ,OAAIA,EAASC,SAC1BF,KAAK,SAAAE,GAAI,OAAIA,EAAKC,KAAKf,SACvBgB,MAAM,SAAAC,GAAG,OAAIC,QAAQC,IAAIF,QAG5BG,aAAe,WAcb,OAXed,EAAKV,MAAMI,OAAOd,IAAI,SAACmC,GACpC,OACEhD,EAAAC,EAAAC,cAAC+C,EAAD,CACE7C,MAAS4C,EAAME,cACfpD,OAASkD,EAAMG,mBACfpC,IAAOiC,EAAMI,GACbzC,OAAUqC,EAAMrC,OAChBC,SAAYoC,EAAMpC,kGApDxBiC,QAAQC,IAAI,iEAIbD,QAAQC,IAAI,qBAWXO,KAAK5B,8CA4CE,IACAE,EAAU0B,KAAK9B,MAAfI,OACP,OAIE3B,EAAAC,EAAAC,cAAA,OAAKG,UAAWsB,EAAS,MAAQ,gBAC9BA,EAAS0B,KAAKN,eAAiB,kBAxEtBO,aCLAC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCDNC,IAASC,OAAO7D,EAAAC,EAAAC,cAAC4D,EAAD,MAASC,SAASC,eAAe,SDgH3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAM5B,KAAK,SAAA6B,GACjCA,EAAaC","file":"static/js/main.664d8387.chunk.js","sourcesContent":["import React  from 'react';\r\nimport './Movie.css';\r\nimport PropTypes from 'prop-types';\r\nimport LinesEllipsis from 'react-lines-ellipsis'\r\n\r\n/*\r\n    9. Smart vs Dumb Components \r\n    모든 컴포넌트가 state이 있는 것은 아니다.\r\n    어떤 컴포넌트는 state이 없는 stateless functuional 컴포넌트이다.\r\n    \r\n    이 두개의 컴포넌트는 큰 차이점이 있다.\r\n    한 개는 state이 있고, 나머지 한 개는 state이 없고, 필요하지도 않다.\r\n    이것을 dumb(멍청한), smart(똑똑한) 컴포넌트라고 한다.\r\n    smart 컴포넌트는 state이 있고, \r\n    dumb 컴포넌트는 state이 없다.(갖고 있는 것은 props 뿐이다.)\r\n    state이 없고, props밖에 없을때는 클래스 컴포넌트를 쓰는 대신에 functional 컴포넌트로 바꾸면 된다. \r\n    정확히 말하면, sateless functional 컴포넌트라고 한다.\r\n    \r\n    예를 들어, movie poster를 갖는 대신에 요소들이 필요없다고 하자.\r\n    이를 stateless functional 컴포넌트로 바꾸는 방법은 function MoviePoster\r\n*/\r\n/*\r\n    이 컴포넌트는 componentWillMount, function , update state가 필요없다.\r\n    그냥 한개의 props만 있으면 된다. poster와 같이 \r\n   \r\n    즉, state가 없다.\r\n    function render가 없고, 라이프 사이클도 없다.\r\n    갖고 있는것은 return 밖에 없다.\r\n    state을 잃게 되어, 업데이트 하는 기능들은 사용을 못한다.Components\r\n*/\r\n\r\nfunction Movie({title , poster, genres, synopsis}) {\r\n    return( \r\n        <div className = \"Movie\">\r\n            <div className =\"Moview_Colum\">\r\n                <MoviePoster poster={poster} alt={title}/>           \r\n            </div>\r\n            <div className=\"Movie_Colum\">\r\n                <h1>{title}</h1>\r\n                <div className=\"Movie_Genres\">\r\n                    {genres.map( (genre, index) => <MovieGeners genre={genre} key={index}/>)}\r\n                    <p className=\"Movie_Synopsis\">\r\n                        <LinesEllipsis\r\n                            text={synopsis}\r\n                            maxLine='3'\r\n                            ellipsis='...'\r\n                            trimRight\r\n                            basedOn='letters'\r\n                        />   \r\n                    </p>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nfunction MoviePoster({poster, alt}) {\r\n    return (\r\n        <img src={poster} alt={alt} title={alt} className=\"Movie_Poster\"/>\r\n    )\r\n}\r\n\r\n// 컴포넌트를 생성한 이유는 더 세련된 코딩방식이다.\r\nfunction MovieGeners({genre}) {\r\n    return(\r\n        <span className = \"Movie_Genre\">{genre}</span>\r\n    )\r\n}\r\n\r\n//  prop types 확인\r\nMoviePoster.propTypes = {\r\n    poster: PropTypes.string.isRequired,\r\n    alt: PropTypes.string.isRequired\r\n}\r\n\r\nMovie.propTypes = {\r\n    title: PropTypes.string.isRequired,\r\n    poster: PropTypes.string.isRequired,\r\n    genres: PropTypes.array.isRequired,\r\n    synopsis: PropTypes.string.isRequired\r\n}\r\n\r\nMovieGeners.propTypes = {\r\n    genre: PropTypes.string.isRequired\r\n}\r\nexport default Movie;","import React , {Component} from 'react';\r\nimport './App.css';\r\nimport Movie from './Movie';\r\n\r\n  /*\r\n    8. loading states \r\n    자신이 필요한 데이터가 항상 바로 즉시 존재하지는 않는다.\r\n    데이터 없이 컴포넌트가 로딩을 하고, \r\n    데이터를 위해 API를 불러서, \r\n    API가 데이터를 주면, \r\n    자신의 컴포넌트 state를 업데이트를 하게 된다.\r\n    \r\n    API콜을 타임아웃 기능으로 유사하게 구혀해보자.\r\n    영화가 state에 없을 때마다 로딩을 띄우거나, \r\n    영화리스트를 보이도록 하자.\r\n  */\r\n \r\n  class App extends Component {\r\n    state = {\r\n      greeting : \"Hello\",\r\n    }\r\n\r\n    componentWillMount() {\r\n      console.log(\"compoentWillMount\");\r\n    }\r\n  \r\n    componentDidMount() {\r\n     console.log(\"componentDidMount\");\r\n      /*\r\n        then function은 1개의 attribute만 준다.\r\n        그리고 fetch의 결과물은 오브젝트이다.   \r\n        If you want change a state \r\n        ->  you may be has a CALLBACK HELL!!!\r\n        fetch(\"https://yts.lt/api/v2/list_movies.json?sort_by=download_count\")\r\n        .then(response => response.json())\r\n        .then(json => console.log(json))\r\n        .catch(err => console.log(err))\r\n      */\r\n      this._getMovies();\r\n    }\r\n    \r\n    // 이전 라인의 작업이 끝날때까지 기다리는 것이 아닐때\r\n    // asynchronous는 이전 작업이 끝나야 그 다음 작업이 시작하는 형태가 아니다.\r\n    // 순서와 상관없이 작업이 진행된다.\r\n    _getMovies = async () => {\r\n      // callApi의 return value를 movies에 set할거다.\r\n      // async를 안쓰면 await이 작동을 안한다.\r\n      const movies = await this._callApi();\r\n      // 이 컴포넌트의 setState을 movies로 할거다.\r\n      // movies는 callApi의 return value이다.\r\n      // 이 setState는 callApi작업이 완료되기(성공적 수행은 아니다.) 전 까지는 실행되지 않는다.\r\n      // 성공적 수행이 되든 실패가 된든 작업이 완료가 되어야 한다.\r\n      // 그 후에 실행이 된다.\r\n      this.setState({\r\n         movies\r\n      });\r\n    };\r\n\r\n    _callApi  = () => {\r\n      return fetch(\"https://yts.lt/api/v2/list_movies.json?sort_by=download_count\")\r\n      .then(response => response.json())\r\n      .then(json => json.data.movies)\r\n      .catch(err => console.log(err)) \r\n    }\r\n\r\n    _rederMovies = () => {\r\n      // component of index is very lose...\r\n      // very slowwwww...\r\n      const movies = this.state.movies.map((movie) => {\r\n        return (\r\n          <Movie \r\n            title = {movie.title_english} \r\n            poster= {movie.medium_cover_image} \r\n            key = {movie.id} \r\n            genres = {movie.genres} \r\n            synopsis = {movie.synopsis}\r\n          />\r\n        );\r\n      });\r\n      return movies;\r\n    };\r\n\r\n    render() {\r\n      const {movies} = this.state;\r\n      return (\r\n      // 자신이 찾고있는 데이터가 있느지 체크를 하고, 자바스크립트에게 물어본다.\r\n      // 만약 참이면 _rederMovies()를 실행\r\n      // 거짓이면 Loding을 출력\r\n        <div className={movies ? \"App\" : \"App--loading\"}>\r\n          {movies ? this._rederMovies() : \"Loading\"}\r\n        </div>\r\n      );\r\n    }\r\n  }\r\n\r\n  export default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n/*\n    index.js는 React, reactDOM, css, 컴포넌트 'App'을 불러온다.\n*/\n\n/*\n    한개의 컴포넌트를 render하고 있다.\n    컴포넌트 이름은 App\n    그 App 컴포넌트 안에 여러개의 컴포넌트를 만들 수 있다.\n    !!하지만 출력은 1개만 하고 있다.!!\n*/\n\n// (component , where)\nReactDOM.render(<App />, document.getElementById('root'));\nserviceWorker.unregister();\n\n/*\n    react : UI ribrary\n    reactDOM : 리액트를 웹사이트에 출력(render)하는 걸 도와주는 모델이다.\n    DOM(Document Object Model)\n*/\n\n/*\n    리액트를 사용해서 웹사이트에 올려 놓고 싶다면 reactDOM을 사용\n    리액트를 모바일 앱에 오려놓고 싶다면 reactNative\n\n    So, react = ribrary , reactDOM = ribrary를 웹사이트에 출력\n    reactDOM은 1개의 컴포넌트를 출력(render)하고 \n    그 다큐먼트 안에 엘리먼트가 있는데, 엘리먼트 ID는 root다.\n    이건 index.html파일에 숨어 있다.\n    그래서 렌더를 하면 모든 컴포넌트들이 index.html에 출력\n*/\n"],"sourceRoot":""}